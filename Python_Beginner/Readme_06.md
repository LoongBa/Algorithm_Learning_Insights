# 小学生 算法入门 案例精讲系列 2024 Python 版

## 系列之六：辗转相除法求最大公约数，继续练习迭代和递归

---

**说明：**

> 本文内容较长，持续更新中，连载于：
> 
> - `github` [loongba/Algorithm_Learning_Insights](https://github.com/LoongBa/Algorithm_Learning_Insights)
> 
> - `gitcode` [loongba/Algorithm_Learning_Insights](https://gitcode.com/LoongBa/Algorithm_Learning_Insights)
> 
> - `gitee` [loongba/Algorithm_Learning_Insights](https://gitee.com/LoongBa/Algorithm_Learning_Insights)
> 
> - [loongba 个人网站1](https://coffeedrunk.cn) | [loongba 个人网站2](https://loongba.cn)

在 `github` 或 `markdown` 编辑器中阅读本文时，可打开其目录功能方便浏览和跳转。

> - `github` 页面中，点击文档右上角的目录图标；
> 
> - `marktext` 编辑器中，按 `Ctrl-K`

---

## 算法入门 案例精讲 Python 版 目录

0. [前言：使用说明](README.md)

1. [求回文数，练习拆分数字和进制转换](Readme_01.md)

2. [求水仙花数，了解枚举和迭代](Readme_02.md)

3. [判断素数，初步学习穷举法及优化](Readme_03.md)

4. [求阶和、阶乘，学习迭代和递归](Readme_04.md)

5. [求斐波那契数列，学习迭代和递归](Readme_05.md)

6. [辗转相除法求最大公约数，继续练习迭代和递归](Readme_06.md)

7. [求解汉诺塔问题，继续练习迭代和递归](Readme_07.md)

8. [求解迷宫问题，初步学习回溯](Readme_08.md)

9. [求解八皇后问题，继续练习回溯](Readme_09.md)

---

# 六、辗转相除法求最大公约数，继续练习迭代和递归

这一节继续练习递推和递归，用辗转相除法求两个数字的最大公约数。

#### 背景知识：

> 辗转相除法（欧几里德算法）是一种用于计算两个整数的最大公约数的方法。
> 
> 辗转相除法来自于古希腊数学家欧几里德 `Euclidean`，他在公元前300年左右的著作《几何原本》中首次描述了这个算法，因此也被称为欧几里德算法（`Euclidean algorithm`）。
> 
> 据传，欧几里德的弟子乌克拉底 `Uclides` 向欧几里德请教如何找到两个数的最大公约数。欧几里德很快就给了他一个简单而巧妙的方法。他告诉乌克拉底，如果两个数能够整除，那么其中较小的数就是最大公约数。但是，如果两个数不能整除，那么我们用较小的数去除以较大的数，然后再用余数去除以刚才的较小数。这个过程一直重复下去，直到找到一个能整除的数，这个数就是最大公约数。
> 
> 辗转相除法的思想是利用两个整数的除法运算和取余运算来逐步缩小问题的规模，直到找到最大公约数。这个算法的重要性在于它是一种高效的方法，即使在大整数的情况下也能很快地求解最大公约数。
> 
> （小学阶段学习的求两个数的最大公因数的方法是`短除法`，可另行练习）

#### 题目要求：

> 请编写一个函数 `gcd(a, b)`，其中 `a` 和 `b` 分别是两个整数。函数要求使用欧几里德算法（辗转相除法）求解 `a` 和 `b` 的最大公约数，并返回结果。
> 请确保函数的输入和输出与上述要求一致。

#### 思路分析：

> 欧几里德算法的关键在于不断用较小的数去除以较大的数，然后用余数去除以刚才的较小数，直到找到一个能整除的数，该数即为最大公约数。
> 可以使用循环或递归来实现欧几里德算法。

#### 编程练习：递推与递归

> [求最大公约数 C 代码](https://github.com/coffeescholar/C_CPP-Learning/blob/main/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0/06_%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0_%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95_%E7%BB%83%E4%B9%A0%E9%80%92%E5%BD%92.c)

请自行实现，参考代码如下，分别用递推和递归方式：

```python
# 用递推方式实现欧几里德算法
def gcd_Iterative(a:int, b:int):
    if a < b:
        a, b = b, a  # 交换 a 和 b 的值，确保 a 大于等于 b
    while b != 0:    # 循环的终止条件
        a, b = b, a % b
    return a

# 用递归方式实现欧几里德算法
def gcd_Recursive(a:int, b:int):
    if a < b:
        a, b = b, a   # 交换 a 和 b 的值，确保 a 大于等于 b
    if b == 0:        # 递归的终止条件
        return a
    else:
        # 将 b 和 a 除以 b 的余数，作为新的 'a, b' 递归调用自己
        return gcd_Recursive(b, a % b)
```

这两个函数使用递归的方式来计算两个整数 a 和 b 的最大公约数：

> 在开始之前，先判断了 `a` 和 `b` 的大小关系，并在需要时交换它们的值，以`确保 a 大于等于 b`。**注意：确保严谨。**
> 
> 然后，在递推的循环，或递归过程中，反复将较大的数除以较小的数的余数，直到`余数为 0`，此时较小的数即为最大公约数。

```python
a = 30
b = 45
print(gcd_Iterative(a, b))   # 输出：15
print(gcd_Recursive(a, b))   # 输出：15
```

#### 编程拓展：

注意：在上面的函数中，交换两个数值采用了 Python 特有的语法：

`a, b = b, a` 对应标准的编程方式应该引入中间变量，为：

```python
c = a
a = b
b = c
```

思考：对于**两个正整数**，是否可以不引入新的变量完成交换？

先不要看下面的答案，利用数学特性：两个数的和，减去其中一个得到另外一个。

```python
a = 10
b = 20

a = a + b
b = a - b
a = a - b

print(a)  # 输出：20
print(b)  # 输出：10
```

以后，还会学到另外一种计算方法：`异或`，先简单看一下：

```python
a = 10
b = 20

a = a ^ b
b = a ^ b
a = a ^ b

print(a)  # 输出：20
print(b)  # 输出：10
```

在这个方法中，使用了异或运算符 `^` 来完成交换。

> 异或运算符有一个特性：对于两个相同的数进行异或运算会得到 0。
> 
> 所以，通过连续进行异或运算，可以完成两个变量的交换。
> 
> 首先，将 a 与 b 进行异或运算，结果存储在 a 中；
> 然后，再次将 a 与 b 进行异或运算，这时 a 存储的是原先的 b 的值；
> 最后，再次将 a 与 b 进行异或运算，这时 a 存储的是原先的 a 的值。
> 
> 经过这三次异或运算，a 和 b 的值完成了交换。

请注意，这种方法**只适用于正整数，对于其他类型的数据可能会产生不可预测的结果**。

---
